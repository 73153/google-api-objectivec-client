#summary Introduction for Objective-C Developers
#labels Featured

<wiki:toc max_depth="4" />

= Introduction to the Google APIs Objective-C Client Library =

Google APIs allow client software to access and manipulate data hosted by Google services.

The Google APIs Objective-C Client Library is a Cocoa framework that enables developers for Mac OS X and iOS to easily write native applications using Google's JSON-RPC APIs.  The framework handles

  * JSON parsing and generation
  * Networking
  * Sign-in for Google accounts
  * Service-specific protocols and query generation


== Requirements ==

The Google APIs Objective-C Client Library requires iOS 3 or later, or Mac OS X 10.5 or later.

== Example Applications ==

The Examples directory contains example applications showing typical interactions with Google services using the framework.  The applications act as simple browsers for the data classes for each service.  The !WindowController source files of the samples were written with typical Cocoa idioms to serve as quick introductions to use of the APIs.  

The example applications run on Mac OS X, but the library does not provide any user interface support apart from authentication, so use of the library APIs is the same for Mac and iOS applications.

In order to use the example applications, you must create client ID and client Secret strings for an *installed application* (not a web application) using the [https://code.google.com/apis/console/ API Console], as explained in the [http://code.google.com/p/gtm-oauth2/wiki/Introduction OAuth 2 controller documentation].

== Adding the Library to a Project ==

BuildingTheLibrary explains how to add the library to a Mac or iPhone application project.

== Subsidiary Libraries ==

The Google APIs Library for Objective-C uses the prefix `GTL`. 

The library incorporates other Google libraries with the `GTM` prefix. Those provide http handling (gtm-http-fetcher) and OAuth 2 authentication (gtm-oauth2).  The library uses the SBJSON library for JSON parsing and generation.

All external libraries needed are checked out automatically with the main API library using subversion's externals facility.

== Authentication and Authorization ==

*Authentication* is the confirmation of a user's identity via her username, password, and possibly other data, such as captcha answers or 2-step codes provided via mobile phone. Authentication is required for access to non-public data. 

Google APIs rely on OAuth 2 for user sign-in. The library includes the [http://code.google.com/p/gtm-oauth2/ GTM OAuth 2 controllers] for iOS and Mac OS X to handle the sign-in sequence. A `GTMOAuth2Authentication` object encapsulates the resulting access tokens.

*Authorization* is the use of access tokens to allow specific requests. Applications pass the OAuth 2 authorization object to a service class's `setAuthorizer:` method.

== Google APIs Objective-C Client Library Basics ==

=== Queries and GTLObjects ===

Servers respond to client API requests with objects.  Objects are typically either individual items, or a collection with an `items` property that returns an `NSArray` of items.

For example, a search for products would return a `GTLShoppingProducts` container object, where the items of the object are the individual product results found by the search.

The individual items are derived from *GTLObject*. The collection is derived from *GTLCollectionObject*, which is a `GTLObject` that also provides an `itemAtIndex:` method and implements the `NSFastEnumeration` protocol.

Each request to the server is a *query*. Server interactions in the library are handled by *service objects*.  A single transaction with a service is tracked with a *service ticket*.

For example, here is how to use the API library to execute a search for hiking boots.
{{{
// Create a service object for executing queries
GTLServiceGoogleShopping *service = [[GTLServiceGoogleShopping alloc] init];

// Create a query
GTLQueryShopping *query = [GTLQueryShopping queryForProductsListWithSource:@"public"];
query.q = @"hiking boots";

// Execute the query
GTLServiceTicket *ticket = [service executeQuery:query
                               completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) {
  // This callback block is run when the fetch completes
  if (error == nil) {
    GTLShoppingProducts *products = object;

    for (GTLShoppingProduct *item in products) {
      // Print the name of each product result item
      NSLog(@"%@", item.product.title);
    }
  }
};
}}}

Unseen by the application, the server is returning a JSON tree in response to queries.  Each `GTLObject`, such as `GTLShoppingProducts` in the example above, is a wrapper for a tree of JSON data. The `GTLObject` allows the JSON data to be treated like a first-class Objective-C object, using normal Objective-C property notation. This is visible in the code snippet above, where the product results are accessible as `products.items`.  

`GTLObject`'s support for properties allows compile-time syntax checking and enables Xcode's autocompletion for each object.  The header files for each object class clearly define the fields of each objects. For example, the shopping products object interface looks in part like this:

{{{
@interface GTLShoppingProducts : GTLObject
@property (retain) NSString *identifier;
@property (retain) NSArray *items;  // of GTLShoppingProduct
@property (retain) NSNumber *currentItemCount;  // integer only
@property (retain) GTLShoppingProductsSpelling *spelling;
...
@end
}}}

Each object property returns either a standard Objective-C type (NSString, NSNumber, NSArray), other `GTLObjects`, or `GTLDateTime`.

When your application gets a property from a `GTLObject`, the library converts the property name to the JSON key string to get or set the result in the underlying JSON tree.  Subtrees of the JSON are returned wrapped in a new `GTLObject`s. To reduce memory overhead, the `GTLObjects` are not created for inner trees of the JSON until they are accessed by the application.

Normally, applications will not need to access the plain JSON tree, but it is available for each `GTLObject` as a dictionary with the property `JSON`.

For compatibility with iOS 3 and Mac OS X 10.5, queries may also be executed with a delegate and selector for the callback:
{{{
GTLServiceTicket *ticket = [service executeQuery:query
                                        delegate:self
                                finishedSelector:@selector(serviceTicket:finishedWithObject:error:)];
}}}

=== Services and Tickets ===

Service objects maintain cookies and track other persistent data across queries. Typically, an application will create a single instance of a service object to use for executing all queries.

Query execution by the service is inherently asynchronous. There is no need create an operation queue or use GCD to run queries on other threads. Callbacks are always run on the same thread that began the query execution. Generally, it's best to execute queries on the main application thread. Any number of queries may be executed either concurrently or sequentially, subject to rate limits shown in the [https://code.google.com/apis/console API Console].

A new ticket is created each time a query is executed by the service. When a ticket is created, many of the ticket properties, such as retry settings and surrogates (both described below), are initialized from the service's properties.

The application may choose to retain the ticket after a query starts executing, allowing the user to cancel the service request.

To cancel a query in progress, call `[ticket cancelTicket]`.  Once the callback has been invoked, the ticket is no longer useful and may be released.

The query being executed by a ticket is available as`ticket.executingQuery`. The `GTMHTTPFetcher` object used to execute the query is accessible as `ticket.objectFetcher`.

=== Result Pages ===

A query may return an object with a subset of the results, called *pages*. When a result object includes a *nextPageToken* string, then a copy of the query can be executed with the token set as the *pageToken* property of the new query, fetching the next set of results. 
{{{
// Manually make a query to fetch the next feed of the result pages
GTLQueryTasks *nextQuery = [[previousQuery copy] autorelease];
query.pageToken = object.nextPageToken;
ticket = [service executeQuery:query ...
}}}

For APIs that offer this style of pagination, the library can automatically fetch all pages, and return an object whose items array includes the items of all pages (up to 25 pages). This can be turned on by setting the `shouldFetchNextPages` property of a service or a ticket:
{{{
// Turn on automatic page fetches
service.shouldFetchNextPages = YES;
}}}

Note, however, that results spread over many pages may take a long time to be retrieved, as each page fetch will lead to a new http request.  The server can be told to use a larger page size (that is, more item in each page returned) by fetching a query for the feed with a `maxResults` value:

{{{
// Specify a large page size to reduce the need to fetch additional result pages
GTLQueryTasks *query = [GTLQueryTasks queryForTasklistsList];
query.maxResults = 1000;
ticket = [service executeQuery:query ...
}}}

Ideally, maxResults will be large enough that, for typical user data, all results will be returned in a single page.

For queries that search public data, with potentially a very large number of items resulting, `shouldFetchNextPages` should be turned off for the service or the ticket.

== Query Operations ==

Query objects typically implement these basic operations:
  * list - fetch a list of items
  * insert - add an item to a list
  * update - replace an item in a list
  * delete - remove an item

There may be custom query operations as well.  To find the Objective-C query class for a documented API operation, search for the *method name* shown in the JSON-RPC documentation for the API.  It is listed before each method name in the query class interface, as shown here for the method named "shopping.products.list":
{{{
// Method: shopping.products.list
// Returns a list of products and content modules
// Fetches a GTLShoppingProducts.
+ (id)queryForProductsListWithSource:(NSString *)source;
}}}

== Creating GTLObjects from scratch ==

Typically, `GTLObject`s are created by the library from JSON returned from a server, but occasionally it is useful to create one from scratch, such as when inserting a new entry.  The `+object` method creates an empty instance of a `GTLObject`.

This snippet shows how to create a new task list for the user's Google Tasks account:
{{{
- (void)addATaskListWithTitle:(NSString *)title {
  GTLTasksTaskList *tasklist = [GTLTasksTaskList object];
  tasklist.title = title;

  GTLQueryTasks *query = [GTLQueryTasks queryForTasklistsInsertWithObject:tasklist];

  [service executeQuery:query
      completionHandler:^(GTLServiceTicket *ticket, id item, NSError *error) {
        // Callback
        if (error == nil) {
          // Succeeded
          GTLTasksTaskList *tasklist = item;
        }
      }];
}
}}}

== Batch Operations ==

Several queries may be executed together in a *batch*. Batch execution is faster than is executing queries individually.

The result of  executing a batch query is two dictionaries, one for the results of successful queries, and one for the error objects returned by unsuccessful queries. 

Note that in addition to the dictionary of error results, there is also an NSError which indicates if the execution did not succceed.

{{{
GTLBatchQuery *batchQuery = [GTLBatchQuery batchQuery];
[batchQuery addQuery:query1];
[batchQuery addQuery:query2];

[service executeQuery:batchQuery
    completionHandler:^(GTLServiceTicket *ticket, id object, NSError *error) {
    if (error == nil) {
      // Execute succeeded: step through the query successes
      // and failures in the result
      GTLBatchResult *batchResult = object;

      NSDictionary *successes = batchResult.successes;
      for (NSString *requestID in successes) {
        GTLObject *result = [successes objectForKey:requestID];
      }

      NSDictionary *failures = batchResults.failures;
      for (NSString *requestID in failures) {
        GTLErrorObject *errorObj = [failures objectForKey:requestID];
      }
    } else {
      // error is non-nil so execute failed: no success or failure
      // results were obtained from the server
    }
  }];
}}}

Each query object is created with a unique `requestID`, though your application may replace the default with a custom `requestID` string for the query prior to execution. The `requestID` string must be non-empty, and all queries in a batch must have unique `requestID`s.

== Adding Custom Data ==

Often it is useful to add data locally to a `GTLObject`. For example, an entry used to represent a photo being uploaded would be more convenient if it also carried a path to the photo's file on the local disk.

Your application can add data to any instance of a `GTLObject` in three ways. These three techniques only add data to objects _locally_ for the Objective-C code; the data will not be retained on the server.

=== userData ===

Each `GTLObject` has a `userData` property to set and retrieve a single NSObject. Adding a local path string to a photo entry `userData` would look like this:

{{{
GTLPhoto *newPhoto = [GTLPhoto object];
newPhoto.userData = localPathString;
}}}

=== User Properties ===

An application can set and retrieve multiple objects as named properties of any `GTLObject` instance with the methods `setProperty:forKey:` and `propertyForKey:`. Unlike `userData`, this is useful for attaching multiple properties.

{{{
GTLPhoto *newPhoto = [GTLPhoto object];
[newPhoto setProperty:localPathString forKey:@"myPath"];
[newPhoto setProperty:thumbnailImage forKey:@"myThumbnail"];
}}}

Property keys beginning with an underscore are reserved by the library and should not be used by applications.

=== Subclassing GTLObjects ===

Finally, applications may subclass `GTLObject`s to add ivars and methods.  To have your subclasses be instantiated in place of the standard object class during the parsing of JSON as part of query execution, set the `surrogates` property of the service:

{{{
GTLServicePhotos *service = [[GTLServicePhotos alloc] init];

service.surrogates = [NSDictionary dictionaryWithObjectsAndKeys:
  [MyPhoto class], [GTLPhoto class],
  [MyAlbum class], [GTLAlbum class],
  nil];
}}}

== Passing Objects to Query Callbacks ==

It is often useful to pass an object to a callback, particularly when using selector callbacks rather than blocks. 

To retain an object from query execution until its callback is invoked, use `GTLServiceTicket`'s `setProperty:forKey:` methods.  For example:

{{{
GTLServiceTicket *ticket = [service executeQuery:...];
[ticket setProperty:callbackData forKey:@"myCallbackData"];
}}}

The callback can then access the data:
{{{
- (void)ticket:(GTLServiceTicket *)ticket finishedWithObject:(GTLObject *)object error:(NSError *)error {

  id myCallbackData = [ticket propertyForKey:@"myCallbackData"];
  ...
}
}}}

`GTLServiceTicket` also supports a `userData` property, which is a single object to be retained, without an explicit key.

== Automatic Retry ==

GTL service classes and the `GTMHTTPFetcher` class provide a mechanism for automatic retry of a few common network and server errors, with appropriate increasing delays between each attempt.  You can turn on the automatic retry support for a GTL service by setting the `retryEnabled` property.

{{{
// Turn on automatic retry of some common error results
service.retryEnabled = YES;
}}}

The default errors retried are http status 408 (request timeout), 503 (service unavailable), and 504 (gateway timeout), `NSURLErrorNetworkConnectionLost`, and `NSURLErrorTimedOut`.  You may specify a maximum retry interval other than the default of 1 minute, and can provide an optional retry selector to customize the criteria for each retry attempt.

== Using APIs Without Generated Classes ==

The Google APIs Objective-C Client Library includes generated service, query and data classes. These are Objective-C files constructed by processing the output of the [https://code.google.com/apis/discovery/ Google APIs Discovery Service]. The generated classes are derived from `GTLServiceBase`, `GTLQueryBase`, and `GTLObject`.

The library may also be used for Google and non-Google APIs without generated classes. Methods for fetching objects via REST and RPC requests are listed in the "REST Fetch Methods" and "RPC Fetch Methods" sections of `GTLServiceBase.h`.  

For use with RPC queries, instances of `GTLServiceBase` should specify the request URL and API version, such as
{{{
GTLServiceBase *service = [[GTLServiceBase alloc] init];
service.rpcURL = [NSURL URLWithstring:@"https://www.example.com/rpc"];
service.apiVersion = @"v1";
}}}

== Logging HTTP Server Traffic ==

Debugging query execution is often easier when you can browse the JSON and headers being sent back and forth over the network.  To make this convenient, the framework can save copies of the server traffic, including http headers, to files in a local directory.  Your application should call

{{{
[GTMHTTPFetcher setLoggingEnabled:YES]
}}}

to turn on logging.  Normally, logs are written to the directory GTMHTTPDebugLogs in the logs directory.

The logs directory is in the current user's Desktop folder for Mac applications. In the iPhone simulator, the default logs location is the user's home directory. On the iPhone device, the default location is the application's documents folder on the device.  

To locate the folder with the Mac Finder, search for the file name GTMHTTPDebugLogs with the search option "System files are included".

The path to the logs folder can be specified with the `+setLoggingDirectory:` method.

To view the most recently saved logs, use a web browser to open the symlink named !MyAppName_log_newest.html (for whatever your application's name is) in the logging directory.

For each executed query, when logging is enabled, the http log is also available as the property `ticket.objectFetcher.log`

*_iOS Note:_* Logging support is stripped out in non-DEBUG builds by default.  This can be overridden by explicitly setting STRIP_GTM_FETCH_LOGGING=0 for the project.

*_Tip:_* Providing a convenient way for your users to enable logging is often helpful in diagnosing problems when using the API.

== Performance and Memory Improvements ==

Once your application successfully works with Google APIs, review the tips on the [PerformanceTuning Performance Tuning] page.

== Questions and Comments ==

*If you have any questions or comments* about the library or this documentation, please join the [http://groups.google.com/group/google-api-objectivec-client discussion group].